import ballerina/http;
import ballerina/io;
import ballerina/os;
import ballerina/sql as sql;

import ballerina/time;
import ballerina/uuid;
import ballerina/crypto;
import ballerinax/mysql;

// Type definitions
type VaccineRecord record {|
    string name;
    string dose;
    boolean received;
    time:Date? receivedDate;
    boolean isCustom;
    int? offsetMonths;
|};

type UserGD record {|
    string gender;
    string date_of_birth;
|};

// Database configuration
final string DATABASE_NAME = "babadb";

// Function to get MySQL connection string
function getMySQLConnectionString() returns string {
    string? envUri = os:getEnv("MYSQL_URI");
    if envUri is string {
        return envUri;
    }
    // Default to XAMPP MySQL
    return "jdbc:mysql://localhost:3306/babadb?user=root&password=&useSSL=false&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true";
}

// Function to get MySQL connection string without database
function getMySQLConnectionStringNoDB() returns string {
    string? envUri = os:getEnv("MYSQL_URI");
    if envUri is string {
        return envUri;
    }
    // Default to XAMPP MySQL without database
    return "jdbc:mysql://localhost:3306?user=root&password=&useSSL=false&allowPublicKeyRetrieval=true";
}

// Bootstrap function to create database if it doesn't exist
function bootstrapDatabase() returns error? {
    io:println("Bootstrapping database...");
    
    // Connect without specifying database
    mysql:Client bootstrapClient = check new (getMySQLConnectionStringNoDB());
    
    // Create database if it doesn't exist
    sql:ParameterizedQuery createDB = `CREATE DATABASE IF NOT EXISTS babadb`;
    sql:ExecutionResult|sql:Error result = bootstrapClient->execute(createDB);
    if result is sql:Error {
        return result;
    }
    
    // Use the database
    sql:ParameterizedQuery useDB = `USE babadb`;
    sql:ExecutionResult|sql:Error useResult = bootstrapClient->execute(useDB);
    if useResult is sql:Error {
        return useResult;
    }
    
    io:println("Database created successfully");
}

// Function to hash password
function hashPassword(string password) returns string {
    byte[] hashedBytes = crypto:hashSha256(password.toBytes());
    string result = "";
    foreach int i in 0..<hashedBytes.length() {
        result = result + hashedBytes[i].toString();
    }
    return result;
}

// Growth classification types and tables (derived from WHO growth standards)
type GrowthRange record {| 
    float under;
    float min;
    float max;
    float over;
|};

final map<map<GrowthRange>> weightTables = {
    "male": {
        "0": {under: 2.6, min: 3.0, max: 4.2, over: 4.4},
        "1": {under: 3.4, min: 3.9, max: 5.3, over: 5.6},
        "2": {under: 4.2, min: 4.9, max: 6.4, over: 6.9},
        "3": {under: 5.0, min: 5.7, max: 7.2, over: 7.8},
        "4": {under: 5.5, min: 6.2, max: 7.9, over: 8.5},
        "5": {under: 6.0, min: 6.7, max: 8.4, over: 9.1},
        "6": {under: 6.4, min: 7.1, max: 8.9, over: 9.6},
        "7": {under: 6.7, min: 7.4, max: 9.3, over: 10.0},
        "8": {under: 6.9, min: 7.6, max: 9.6, over: 10.4},
        "9": {under: 7.1, min: 7.9, max: 9.9, over: 10.7},
        "10": {under: 7.3, min: 8.1, max: 10.2, over: 11.0},
        "11": {under: 7.5, min: 8.3, max: 10.5, over: 11.3},
        "12": {under: 7.6, min: 8.4, max: 10.8, over: 11.5},
        "13": {under: 7.7, min: 8.6, max: 11.0, over: 11.8},
        "14": {under: 7.8, min: 8.7, max: 11.3, over: 12.1},
        "15": {under: 7.9, min: 8.9, max: 11.5, over: 12.3},
        "16": {under: 8.0, min: 9.0, max: 11.7, over: 12.5},
        "17": {under: 8.1, min: 9.2, max: 11.9, over: 12.7},
        "18": {under: 8.2, min: 9.3, max: 12.1, over: 12.9},
        "19": {under: 8.3, min: 9.4, max: 12.3, over: 13.1},
        "20": {under: 8.4, min: 9.6, max: 12.5, over: 13.3},
        "21": {under: 8.5, min: 9.7, max: 12.7, over: 13.5},
        "22": {under: 8.6, min: 9.8, max: 12.9, over: 13.7},
        "23": {under: 8.7, min: 10.0, max: 13.1, over: 13.9},
        "24": {under: 8.8, min: 10.1, max: 13.3, over: 14.1}
    },
    "female": {
        "0": {under: 2.5, min: 2.8, max: 3.9, over: 4.2},
        "1": {under: 3.2, min: 3.6, max: 4.8, over: 5.2},
        "2": {under: 3.9, min: 4.4, max: 5.9, over: 6.3},
        "3": {under: 4.5, min: 5.1, max: 6.7, over: 7.1},
        "4": {under: 5.0, min: 5.6, max: 7.3, over: 7.8},
        "5": {under: 5.4, min: 6.0, max: 7.8, over: 8.4},
        "6": {under: 5.7, min: 6.4, max: 8.2, over: 8.9},
        "7": {under: 6.0, min: 6.7, max: 8.6, over: 9.3},
        "8": {under: 6.2, min: 7.0, max: 8.9, over: 9.7},
        "9": {under: 6.4, min: 7.2, max: 9.2, over: 10.1},
        "10": {under: 6.6, min: 7.4, max: 9.5, over: 10.4},
        "11": {under: 6.8, min: 7.6, max: 9.7, over: 10.7},
        "12": {under: 6.9, min: 7.7, max: 9.9, over: 11.0},
        "13": {under: 7.0, min: 7.9, max: 10.1, over: 11.2},
        "14": {under: 7.2, min: 8.1, max: 10.3, over: 11.5},
        "15": {under: 7.3, min: 8.3, max: 10.6, over: 11.8},
        "16": {under: 7.4, min: 8.4, max: 10.8, over: 12.0},
        "17": {under: 7.5, min: 8.6, max: 11.0, over: 12.2},
        "18": {under: 7.6, min: 8.7, max: 11.2, over: 12.4},
        "19": {under: 7.7, min: 8.9, max: 11.4, over: 12.6},
        "20": {under: 7.8, min: 9.0, max: 11.6, over: 12.8},
        "21": {under: 7.9, min: 9.1, max: 11.8, over: 13.0},
        "22": {under: 8.0, min: 9.2, max: 12.0, over: 13.2},
        "23": {under: 8.1, min: 9.4, max: 12.2, over: 13.4},
        "24": {under: 8.2, min: 9.5, max: 12.4, over: 13.6}
    }
};

// Function to get default vaccines by gender
function getDefaultVaccines(string gender) returns VaccineRecord[] {
    VaccineRecord[] vaccines = [];
    // First Year of Life (offsets in months from birth)
    vaccines.push({ name: "BCG (Tuberculosis)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
    vaccines.push({ name: "OPV (1st)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 2 });
    vaccines.push({ name: "OPV (2nd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 4 });
    vaccines.push({ name: "OPV (3rd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 6 });
    vaccines.push({ name: "OPV (4th)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 18 });
    vaccines.push({ name: "OPV (5th)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 60 });
    vaccines.push({ name: "Pentavalent (1st)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 2 });
    vaccines.push({ name: "Pentavalent (2nd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 4 });
    vaccines.push({ name: "Pentavalent (3rd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 6 });
    vaccines.push({ name: "fIPV (1st)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 2 });
    vaccines.push({ name: "fIPV (2nd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 4 });
    vaccines.push({ name: "MMR (1st)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 9 });

    // Second Year of Life
    vaccines.push({ name: "Live JE", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 12 });
    vaccines.push({ name: "DTP (4th)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 18 });

    // Pre-School
    vaccines.push({ name: "MMR (2nd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 36 });

    // School Age
    vaccines.push({ name: "DT (5th)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 60 });
    vaccines.push({ name: "HPV (1st)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 120 });
    vaccines.push({ name: "HPV (2nd)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 126 }); // 6 months later
    vaccines.push({ name: "aTd (6th)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 132 });

    if gender == "female" || gender == "Female" || gender == "FEMALE" {
        // Additional for females
        vaccines.push({ name: "Rubella-containing vaccine (MMR)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 180 }); // example offset
        // Pregnant women â€“ TT (placeholders)
        vaccines.push({ name: "Tetanus Toxoid (TT) (1st pregnancy)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
        vaccines.push({ name: "Tetanus Toxoid (TT) (2nd dose)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
        vaccines.push({ name: "Tetanus Toxoid (TT) (3rd dose)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
        vaccines.push({ name: "Tetanus Toxoid (TT) (4th dose)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
        vaccines.push({ name: "Tetanus Toxoid (TT) (5th dose)", dose: "", received: false, receivedDate: (), isCustom: false, offsetMonths: 0 });
    }
    
    return vaccines;
}

// Function to calculate age in months from date of birth
function calculateAgeInMonths(string dateOfBirth) returns int {
    // For now, return a simple calculation based on year difference
    // This is a simplified version - in production you'd want more sophisticated date parsing
    if (dateOfBirth.length() >= 4) {
        string yearStr = dateOfBirth.substring(0, 4);
        int birthYear = 0;
        // Simple year parsing - assume valid year format
        if (yearStr == "2020") {
            birthYear = 2020;
        } else if (yearStr == "2021") {
            birthYear = 2021;
        } else if (yearStr == "2022") {
            birthYear = 2022;
        } else if (yearStr == "2023") {
            birthYear = 2023;
        } else if (yearStr == "2024") {
            birthYear = 2024;
        } else {
            birthYear = 2000; // Default fallback
        }
        
        // Get current date - use a simple approach for now
        int currentYear = 2024; // Hardcoded for now to avoid time parsing issues
        
        // Calculate approximate age in months (12 months per year)
        int ageInMonths = (currentYear - birthYear) * 12;
        
        return ageInMonths;
    }
    
    return 0;
}

// Function to get growth classification based on age, gender, and weight
function getGrowthClassification(string gender, int ageInMonths, float weight) returns string {
    if (weightTables.hasKey(gender)) {
        map<GrowthRange>? genderTable = weightTables[gender];
        if (genderTable is map<GrowthRange>) {
            if (genderTable.hasKey(ageInMonths.toString())) {
                GrowthRange? range = genderTable[ageInMonths.toString()];
                if (range is GrowthRange) {
                    if (weight < range.under) {
                        return "severely_underweight";
                    } else if (weight < range.min) {
                        return "underweight";
                    } else if (weight <= range.max) {
                        return "normal";
                    } else if (weight <= range.over) {
                        return "overweight";
                    } else {
                        return "obese";
                    }
                }
            }
        }
    }
    
    // Fallback to standard BMI classification for older ages
    return "standard_bmi";
}

// Function to initialize database and tables
function initializeDatabase(mysql:Client dbClient) returns error? {
    io:println("Initializing database and tables...");

    // Users table
    sql:ParameterizedQuery createUsersTable = `
        CREATE TABLE IF NOT EXISTS users (
            id VARCHAR(255) PRIMARY KEY,
            first_name VARCHAR(255) NOT NULL,
            last_name VARCHAR(255) NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            password VARCHAR(255) NOT NULL,
            gender VARCHAR(50) NOT NULL,
            date_of_birth DATE NOT NULL,
            phone_number VARCHAR(50),
            vaccines JSON,
            special_notes TEXT,
            photo_data_url TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`;

    // Diseases table
    sql:ParameterizedQuery createDiseasesTable = `
        CREATE TABLE IF NOT EXISTS diseases (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            disease_name VARCHAR(255) NOT NULL,
            diagnosis_date DATE NOT NULL,
            symptoms TEXT,
            treatment TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )`;

    // Appointments table
    sql:ParameterizedQuery createAppointmentsTable = `
        CREATE TABLE IF NOT EXISTS appointments (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            title VARCHAR(255) NOT NULL,
            date DATE NOT NULL,
            time TIME NOT NULL,
            notes TEXT,
            completed BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )`;

    // BMI records table
    sql:ParameterizedQuery createBmiRecordsTable = `
        CREATE TABLE IF NOT EXISTS bmi_records (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            weight FLOAT NOT NULL,
            height FLOAT NOT NULL,
            bmi FLOAT NOT NULL,
            classification VARCHAR(32),
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )`;

    // Vaccine records table
    sql:ParameterizedQuery createVaccineRecordsTable = `
        CREATE TABLE IF NOT EXISTS vaccine_records (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            name VARCHAR(255) NOT NULL,
            dose VARCHAR(255),
            due_date DATE,
            completed_date DATE,
            is_custom BOOLEAN DEFAULT FALSE,
            offset_months INT,
            received BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )`;

    // Doctor appointments table
    sql:ParameterizedQuery createDocAppointmentsTable = `
        CREATE TABLE IF NOT EXISTS doc_appointments (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            date DATE NOT NULL,
            time TIME NOT NULL,
            place VARCHAR(255) NOT NULL,
            disease VARCHAR(255) NOT NULL,
            completed BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )`;

    sql:ExecutionResult|sql:Error r1 = dbClient->execute(createUsersTable);
    if r1 is sql:Error { return r1; }

    sql:ExecutionResult|sql:Error r2 = dbClient->execute(createDiseasesTable);
    if r2 is sql:Error { return r2; }

    sql:ExecutionResult|sql:Error r3 = dbClient->execute(createAppointmentsTable);
    if r3 is sql:Error { return r3; }

    sql:ExecutionResult|sql:Error r4 = dbClient->execute(createBmiRecordsTable);
    if r4 is sql:Error { return r4; }

    sql:ExecutionResult|sql:Error r5 = dbClient->execute(createVaccineRecordsTable);
    if r5 is sql:Error { return r5; }

    sql:ExecutionResult|sql:Error r6 = dbClient->execute(createDocAppointmentsTable);
    if r6 is sql:Error { return r6; }

    io:println("All tables created successfully");
}

// Global MySQL client
mysql:Client? globalClient = ();

// Main function
public function main() {
    error? bootstrapResult = bootstrapDatabase();
    if bootstrapResult is error {
        io:println("Database bootstrap failed: ", bootstrapResult.message());
        return;
    }

    mysql:Client|error dbClientResult = new (getMySQLConnectionString());
    if dbClientResult is error {
        io:println("Database connection failed: ", dbClientResult.message());
        return;
    }
    mysql:Client dbClient = dbClientResult;
    globalClient = dbClient;

    error? initResult = initializeDatabase(dbClient);
    if initResult is error {
        io:println("Database initialization failed: ", initResult.message());
    } else {
        io:println("Database initialized successfully");
    }
    
    // Keep the program running
    io:println("Service is ready. Press Ctrl+C to stop.");
}

@http:ServiceConfig {
    cors: {
        allowOrigins: ["http://localhost:5173", "http://localhost:3000"],
        allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowHeaders: ["Content-Type", "Accept", "Authorization"],
        allowCredentials: true
    }
}
service /health on new http:Listener(9090) {
    // Health check endpoint
    resource function get .() returns http:Ok {
        return <http:Ok>{ body: { message: "Health Records API is running" } };
    }

    // Debug endpoint to check database data
    resource function get debug() returns http:Ok|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        // Check total users
        sql:ParameterizedQuery countQuery = `SELECT COUNT(*) as total FROM users`;
        stream<record {}, sql:Error?> countStream = dbClient->query(countQuery);
        record {}[] countResults = [];
        while true {
            record {}|sql:Error? row = countStream.next();
            if row is record {} { countResults.push(row); } else { break; }
        }
        
        // Get all users with their data
        sql:ParameterizedQuery allUsersQuery = `SELECT * FROM users`;
        stream<record {}, sql:Error?> allUsersStream = dbClient->query(allUsersQuery);
        record {}[] allUsers = [];
        while true {
            record {}|sql:Error? row = allUsersStream.next();
            if row is record {} { allUsers.push(row); } else { break; }
        }
        
        return <http:Ok>{ body: { 
            totalUsers: countResults.length() > 0 ? countResults[0]["total"].toString() : "0",
            users: allUsers
        }};
    }

    // User signup endpoint
    resource function post signup(@http:Payload record {
        string firstName;
        string lastName;
        string email;
        string password;
        string gender;
        string dateOfBirth;
        string? phoneNumber;
    } newUser) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("Signup attempt for email: ", newUser.email);
        
        string userId = uuid:createType4AsString();
        string hashedPassword = hashPassword(newUser.password);
        
        io:println("=== SIGNUP DEBUG ===");
        io:println("Generated userId: ", userId);
        io:println("Raw password from user: ", newUser.password);
        io:println("Raw password length: ", newUser.password.length());
        io:println("Hashed password: ", hashedPassword);
        io:println("Hashed password length: ", hashedPassword.length());
        io:println("===================");
        
        string phoneNum = newUser.phoneNumber ?: "";
        sql:ParameterizedQuery insertUser = `INSERT INTO users (id, first_name, last_name, email, password, gender, date_of_birth, phone_number) VALUES (${userId}, ${newUser.firstName}, ${newUser.lastName}, ${newUser.email}, ${hashedPassword}, ${newUser.gender}, ${newUser.dateOfBirth}, ${phoneNum})`;
        io:println("Insert query: ", insertUser);
        sql:ExecutionResult|sql:Error insRes = dbClient->execute(insertUser);
        if insRes is sql:Error {
            io:println("Error creating user: ", insRes.message());
            return <http:InternalServerError>{ body: { message: "Error creating user" } };
        }
        
        // Automatically assign default vaccines based on gender
        VaccineRecord[] defaultVaccines = getDefaultVaccines(newUser.gender);
        foreach VaccineRecord vaccine in defaultVaccines {
            sql:ParameterizedQuery vaccineQuery = `INSERT INTO vaccine_records (user_id, name, dose, received, received_date, is_custom, offset_months, created_at) VALUES (${userId}, ${vaccine.name}, ${vaccine.dose}, ${vaccine.received}, ${vaccine.receivedDate ?: ""}, ${vaccine.isCustom}, ${vaccine.offsetMonths ?: 0}, NOW())`;
            sql:ExecutionResult|sql:Error vaccineResult = dbClient->execute(vaccineQuery);
            if vaccineResult is sql:Error {
                io:println("Warning: Could not insert vaccine record for", vaccine.name, ":", vaccineResult);
            }
        }
        
        io:println("User created successfully with ID:", userId, "and", defaultVaccines.length(), "default vaccines assigned");
        
        string name = newUser.firstName + " " + newUser.lastName;
        return <http:Created>{ body: { message: "User created successfully", userId: userId, name: name, email: newUser.email, redirectTo: "already-vaccinated" } };
    }

    // Add disease endpoint
    resource function post addDisease(@http:Payload record {
        string userId;
        string diseaseName;
        string diagnosisDate;
        string? symptoms;
        string? treatment;
    } disease) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery insertDisease = `INSERT INTO diseases (user_id, disease_name, diagnosis_date, symptoms, treatment) VALUES (${disease.userId}, ${disease.diseaseName}, ${disease.diagnosisDate}, ${disease.symptoms ?: ""}, ${disease.treatment ?: ""})`;
        sql:ExecutionResult|sql:Error insRes = dbClient->execute(insertDisease);
        if insRes is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding disease" } };
        }
        
        return <http:Created>{ body: { message: "Disease added successfully" } };
    }

    // Get diseases endpoint
    resource function get getDiseases(string userId) returns http:Ok|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        sql:ParameterizedQuery q = `SELECT * FROM diseases WHERE user_id = ${userId} ORDER BY diagnosis_date DESC`;
        stream<record {}, sql:Error?> s = dbClient->query(q);
        record {}[] items = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { items.push(row); } else { break; }
        }
        return <http:Ok>{ body: items };
    }

    // Get user profile endpoint
    resource function get getUserProfile(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery uq = `SELECT id, first_name, last_name, email, gender, date_of_birth, phone_number, photo_data_url FROM users WHERE id = ${userId}`;
        io:println("DEBUG: SQL Query executed for userId: " + userId);
        
        stream<record {}, sql:Error?> s = dbClient->query(uq);
        record {}[] users = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { 
                users.push(row); 
                io:println("DEBUG: Found user row: " + row.toString());
            } else { 
                break; 
            }
        }
        
        io:println("DEBUG: Total users found: " + users.length().toString());
        
        if users.length() == 0 {
            io:println("DEBUG: No users found for userId: " + userId);
            return <http:NotFound>{ body: { message: "User not found" } };
        }
        
        record {} user = users[0];
        io:println("DEBUG: getUserProfile - Raw user data: " + user.toString());
        io:println("DEBUG: User record structure available");
        
        // Transform the data to match frontend expectations (camelCase)
        io:println("DEBUG: Accessing user fields...");
        
        // Handle the nested 'value' field structure from MySQL results
        record {} userData = user;
        if user.hasKey("value") {
            userData = <record {}>user["value"];
            io:println("DEBUG: Found nested 'value' field, using userData");
        }
        
        // Use proper field access for open records
        string dbUserId = userData["id"] is string ? <string>userData["id"] : "";
        io:println("DEBUG: user['id'] = " + dbUserId);
        
        string dbFirstName = userData["first_name"] is string ? <string>userData["first_name"] : "";
        io:println("DEBUG: user['first_name'] = " + dbFirstName);
        
        string dbLastName = userData["last_name"] is string ? <string>userData["last_name"] : "";
        io:println("DEBUG: user['last_name'] = " + dbLastName);
        
        string dbEmail = userData["email"] is string ? <string>userData["email"] : "";
        io:println("DEBUG: user['email'] = " + dbEmail);
        
        string dbGender = userData["gender"] is string ? <string>userData["gender"] : "";
        io:println("DEBUG: user['gender'] = " + dbGender);
        
        string dbDateOfBirth = userData["date_of_birth"] is string ? <string>userData["date_of_birth"] : "";
        io:println("DEBUG: user['date_of_birth'] = " + dbDateOfBirth);
        
        string dbPhoneNumber = userData["phone_number"] is string ? <string>userData["phone_number"] : "";
        io:println("DEBUG: user['phone_number'] = " + dbPhoneNumber);
        
        string? dbPhotoDataUrl = userData["photo_data_url"] is string ? <string>userData["photo_data_url"] : ();
        io:println("DEBUG: user['photo_data_url'] = " + (dbPhotoDataUrl is string ? dbPhotoDataUrl : "null"));
        
        record {
            string id;
            string firstName;
            string lastName;
            string email;
            string gender;
            string dateOfBirth;
            string phoneNumber;
            string? photoDataUrl;
        } transformedUser = {
            id: dbUserId,
            firstName: dbFirstName,
            lastName: dbLastName,
            email: dbEmail,
            gender: dbGender,
            dateOfBirth: dbDateOfBirth,
            phoneNumber: dbPhoneNumber,
            photoDataUrl: dbPhotoDataUrl
        };
        
        io:println("DEBUG: Transformed user data: " + transformedUser.toString());
        
        // Return in the format expected by frontend
        return <http:Ok>{ body: transformedUser };
    }

    // Get vaccines endpoint
    resource function get getVaccines(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: getVaccines called for userId: " + userId);
        
        sql:ParameterizedQuery vq = `SELECT id, user_id, name, dose, due_date, is_custom, created_at, completed_date FROM vaccine_records WHERE user_id = ${userId}`;
        io:println("DEBUG: SQL Query executed for userId: " + userId);
        io:println("DEBUG: Full SQL Query: SELECT id, user_id, name, dose, due_date, is_custom, created_at, completed_date FROM vaccine_records WHERE user_id = " + userId);
        
        stream<record {}, sql:Error?> s = dbClient->query(vq);
        record {}[] vaccines = [];
        
        // Debug: Check if stream has errors
        io:println("DEBUG: Starting to process query results...");
        
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { 
                vaccines.push(row); 
                io:println("DEBUG: Found vaccine row: " + row.toString());
                io:println("DEBUG: Row keys: " + row.keys().toString());
            } else if row is sql:Error {
                io:println("DEBUG: SQL Error encountered: " + row.toString());
                break;
            } else { 
                io:println("DEBUG: End of stream reached");
                break; 
            }
        }
        
        io:println("DEBUG: Total vaccines found: " + vaccines.length().toString());
        
        // Debug: Let's also check what's actually in the database for this user
        if vaccines.length() == 0 {
            io:println("DEBUG: No vaccines found for userId: " + userId);
            io:println("DEBUG: Let's check what's in the vaccine_records table...");
            
            sql:ParameterizedQuery debugQuery = `SELECT COUNT(*) as total FROM vaccine_records`;
            stream<record {}, sql:Error?> debugStream = dbClient->query(debugQuery);
            record {}[] debugResults = [];
            while true {
                record {}|sql:Error? debugRow = debugStream.next();
                if debugRow is record {} { 
                    debugResults.push(debugRow); 
                } else { 
                    break; 
                }
            }
            
            if debugResults.length() > 0 {
                record {} debugResult = debugResults[0];
                io:println("DEBUG: Total records in vaccine_records table: " + debugResult.toString());
            }
            
            // Check specific user's vaccines with a different approach
            sql:ParameterizedQuery userVaccinesQuery = `SELECT * FROM vaccine_records WHERE user_id = ${userId}`;
            stream<record {}, sql:Error?> userVaccinesStream = dbClient->query(userVaccinesQuery);
            record {}[] userVaccines = [];
            while true {
                record {}|sql:Error? userVaccineRow = userVaccinesStream.next();
                if userVaccineRow is record {} { 
                    userVaccines.push(userVaccineRow); 
                    io:println("DEBUG: Direct query found vaccine: " + userVaccineRow.toString());
                } else { 
                    break; 
                }
            }
            
            io:println("DEBUG: Direct query found " + userVaccines.length().toString() + " vaccines for user");
            
            return <http:Ok>{ body: [] };
        }
        
        // Transform the data to handle nested 'value' field and match frontend expectations
        record {
            string id;
            string userId;
            string name;
            string dose;
            string dueDate;
            boolean isCustom;
            string createdAt;
            string? completedDate;
        }[] transformedVaccines = [];
        
        foreach record {} vaccine in vaccines {
            io:println("DEBUG: Processing vaccine: " + vaccine.toString());
            
            // Handle the nested 'value' field structure from MySQL results
            record {} vaccineData = vaccine;
            if vaccine.hasKey("value") {
                vaccineData = <record {}>vaccine["value"];
                io:println("DEBUG: Found nested 'value' field, using vaccineData");
            }
            
            // Extract and transform fields
            string id = vaccineData["id"] is string ? <string>vaccineData["id"] : "";
            string dbUserId = vaccineData["user_id"] is string ? <string>vaccineData["user_id"] : "";
            string name = vaccineData["name"] is string ? <string>vaccineData["name"] : "";
            string dose = vaccineData["dose"] is string ? <string>vaccineData["dose"] : "";
            boolean received = vaccineData["received"] is boolean ? <boolean>vaccineData["received"] : false;
            string? receivedDate = vaccineData["received_date"] is string ? <string>vaccineData["received_date"] : ();
            boolean isCustom = vaccineData["is_custom"] is boolean ? <boolean>vaccineData["is_custom"] : false;
            int? offsetMonths = vaccineData["offset_months"] is int ? <int>vaccineData["offset_months"] : ();
            string? dueDate = vaccineData["due_date"] is string ? <string>vaccineData["due_date"] : ();
            
            io:println("DEBUG: Transformed vaccine - id: " + id + ", name: " + name + ", dose: " + dose + ", dueDate: " + dueDate);
            
            record {
                string id;
                string userId;
                string name;
                string dose;
                string dueDate;
                boolean isCustom;
                string createdAt;
                string? completedDate;
            } transformedVaccine = {
                id: id,
                userId: dbUserId,
                name: name,
                dose: dose,
                dueDate: dueDate,
                isCustom: isCustom,
                createdAt: createdAt,
                completedDate: completedDate
            };
            
            transformedVaccines.push(transformedVaccine);
        }
        
        io:println("DEBUG: Returning " + transformedVaccines.length().toString() + " transformed vaccines");
        return <http:Ok>{ body: transformedVaccines };
    }

    // Update vaccine record endpoint
    resource function put updateVaccine(string userId, string vaccineId, @http:Payload record {
        string? name;
        string? dose;
        boolean? received;
        string? receivedDate;
        boolean? isCustom;
        int? offsetMonths;
        string? dueDate;
    } vaccineData) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: updateVaccine called for userId: " + userId + ", vaccineId: " + vaccineId);
        io:println("DEBUG: Update data: " + vaccineData.toString());
        
        // Build dynamic UPDATE query based on provided fields
        string updateQuery = "UPDATE vaccine_records SET ";
        string[] updateFields = [];
        
        if vaccineData.name is string {
            string nameStr = <string>vaccineData.name;
            updateFields.push("name = '" + nameStr + "'");
        }
        if vaccineData.dose is string {
            string doseStr = <string>vaccineData.dose;
            updateFields.push("dose = '" + doseStr + "'");
        }
        if vaccineData.received is boolean {
            boolean receivedBool = <boolean>vaccineData.received;
            updateFields.push("received = " + (receivedBool ? "1" : "0"));
        }
        if vaccineData.receivedDate is string {
            string receivedDateStr = <string>vaccineData.receivedDate;
            updateFields.push("received_date = '" + receivedDateStr + "'");
        }
        if vaccineData.isCustom is boolean {
            boolean isCustomBool = <boolean>vaccineData.isCustom;
            updateFields.push("is_custom = " + (isCustomBool ? "1" : "0"));
        }
        if vaccineData.offsetMonths is int {
            int offsetMonthsInt = <int>vaccineData.offsetMonths;
            updateFields.push("offset_months = " + offsetMonthsInt.toString());
        }
        if vaccineData.dueDate is string {
            string dueDateStr = <string>vaccineData.dueDate;
            updateFields.push("due_date = '" + dueDateStr + "'");
        }
        
        if updateFields.length() == 0 {
            return <http:InternalServerError>{ body: { message: "No fields to update" } };
        }
        
        // Build the query string manually since join() is not available
        string fieldsString = "";
        foreach int i in 0..<updateFields.length() {
            if i > 0 {
                fieldsString = fieldsString + ", ";
            }
            fieldsString = fieldsString + updateFields[i];
        }
        
        updateQuery = updateQuery + fieldsString + " WHERE id = " + vaccineId + " AND user_id = " + userId;
        io:println("DEBUG: SQL Update query: " + updateQuery);
        
        sql:ExecutionResult|sql:Error result = dbClient->execute(`UPDATE vaccine_records SET ${fieldsString} WHERE id = ${vaccineId} AND user_id = ${userId}`);
        if result is sql:Error {
            io:println("DEBUG: Error updating vaccine: " + result.toString());
            return <http:InternalServerError>{ body: { message: "Failed to update vaccine record" } };
        }
        
        io:println("DEBUG: Vaccine updated successfully");
        return <http:Ok>{ body: { message: "Vaccine updated successfully" } };
    }

    // Get default vaccines endpoint
    resource function get getDefaultVaccines(string gender) returns http:Ok|http:InternalServerError|error {
        io:println("DEBUG: getDefaultVaccines called for gender: " + gender);
        
        VaccineRecord[] defaultVaccines = getDefaultVaccines(gender);
        io:println("DEBUG: Returning " + defaultVaccines.length().toString() + " default vaccines for " + gender);
        
        return <http:Ok>{ body: defaultVaccines };
    }

    // Create custom vaccine endpoint
    resource function post createCustomVaccine(string userId, @http:Payload record {
        string name;
        string dose;
        boolean received;
        string? receivedDate;
        int? offsetMonths;
        string? dueDate;
    } vaccineData) returns http:Ok|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: createCustomVaccine called for userId: " + userId);
        io:println("DEBUG: Vaccine data: " + vaccineData.toString());
        
        sql:ParameterizedQuery insertQuery = `INSERT INTO vaccine_records (user_id, name, dose, received, received_date, is_custom, offset_months, due_date, created_at) VALUES (${userId}, ${vaccineData.name}, ${vaccineData.dose}, ${vaccineData.received}, ${vaccineData.receivedDate ?: ""}, true, ${vaccineData.offsetMonths ?: 0}, ${vaccineData.dueDate ?: ""}, NOW())`;
        io:println("DEBUG: SQL Insert query executed for userId: " + userId);
        
        sql:ExecutionResult|sql:Error result = dbClient->execute(insertQuery);
        if result is sql:Error {
            io:println("DEBUG: Error creating custom vaccine: " + result.toString());
            return <http:InternalServerError>{ body: { message: "Failed to create custom vaccine record" } };
        }
        
        io:println("DEBUG: Custom vaccine created successfully");
        return <http:Ok>{ body: { message: "Custom vaccine created successfully" } };
    }

    // Get doctor appointments endpoint
    resource function get getDocAppointments(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: getDocAppointments called for userId: " + userId);
        
        sql:ParameterizedQuery aq = `SELECT id, user_id, date, time, place, disease, completed FROM doc_appointments WHERE user_id = ${userId}`;
        io:println("DEBUG: SQL Query executed for userId: " + userId);
        
        stream<record {}, sql:Error?> s = dbClient->query(aq);
        record {}[] appointments = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { 
                appointments.push(row); 
                io:println("DEBUG: Found appointment row: " + row.toString());
            } else { 
                break; 
            }
        }
        
        io:println("DEBUG: Total appointments found: " + appointments.length().toString());
        
        if appointments.length() == 0 {
            io:println("DEBUG: No appointments found for userId: " + userId);
            return <http:Ok>{ body: [] };
        }
        
        // Transform the data to handle nested 'value' field and match frontend expectations
        record {
            string id;
            string userId;
            string date;
            string time;
            string place;
            string disease;
            boolean completed;
        }[] transformedAppointments = [];
        
        foreach record {} appointment in appointments {
            io:println("DEBUG: Processing appointment: " + appointment.toString());
            
            // Handle the nested 'value' field structure from MySQL results
            record {} appointmentData = appointment;
            if appointment.hasKey("value") {
                appointmentData = <record {}>appointment["value"];
                io:println("DEBUG: Found nested 'value' field, using appointmentData");
            }
            
            // Extract and transform fields
            string id = appointmentData["id"] is string ? <string>appointmentData["id"] : "";
            string dbUserId = appointmentData["user_id"] is string ? <string>appointmentData["user_id"] : "";
            string date = appointmentData["date"] is string ? <string>appointmentData["date"] : "";
            string time = appointmentData["time"] is string ? <string>appointmentData["time"] : "";
            string place = appointmentData["place"] is string ? <string>appointmentData["place"] : "";
            string disease = appointmentData["disease"] is string ? <string>appointmentData["disease"] : "";
            boolean completed = appointmentData["completed"] is boolean ? <boolean>appointmentData["completed"] : false;
            
            io:println("DEBUG: Transformed appointment - id: " + id + ", date: " + date + ", disease: " + disease + ", completed: " + completed.toString());
            
            record {
                string id;
                string userId;
                string date;
                string time;
                string place;
                string disease;
                boolean completed;
            } transformedAppointment = {
                id: id,
                userId: dbUserId,
                date: date,
                time: time,
                place: place,
                disease: disease,
                completed: completed
            };
            
            transformedAppointments.push(transformedAppointment);
        }
        
        io:println("DEBUG: Returning " + transformedAppointments.length().toString() + " transformed appointments");
        return <http:Ok>{ body: transformedAppointments };
    }

    // Get BMI records endpoint
    resource function get getBmiRecords(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: getBmiRecords called for userId: " + userId);
        
        sql:ParameterizedQuery bq = `SELECT id, user_id, weight, height, bmi, classification, notes, created_at FROM bmi_records WHERE user_id = ${userId} ORDER BY created_at DESC`;
        io:println("DEBUG: SQL Query executed for userId: " + userId);
        
        stream<record {}, sql:Error?> s = dbClient->query(bq);
        record {}[] bmiRecords = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { 
                bmiRecords.push(row); 
                io:println("DEBUG: Found BMI row: " + row.toString());
            } else { 
                break; 
            }
        }
        
        io:println("DEBUG: Total BMI records found: " + bmiRecords.length().toString());
        
        if bmiRecords.length() == 0 {
            io:println("DEBUG: No BMI records found for userId: " + userId);
            return <http:Ok>{ body: [] };
        }
        
        // Transform the data to handle nested 'value' field and match frontend expectations
        record {
            string id;
            string userId;
            decimal weight;
            decimal height;
            decimal bmi;
            string classification;
            string? notes;
            string createdAt;
        }[] transformedBmiRecords = [];
        
        foreach record {} bmiRecord in bmiRecords {
            io:println("DEBUG: Processing BMI record: " + bmiRecord.toString());
            
            // Handle the nested 'value' field structure from MySQL results
            record {} bmiData = bmiRecord;
            if bmiRecord.hasKey("value") {
                bmiData = <record {}>bmiRecord["value"];
                io:println("DEBUG: Found nested 'value' field, using bmiData");
            }
            
            // Extract and transform fields
            string id = bmiData["id"] is string ? <string>bmiData["id"] : "";
            string dbUserId = bmiData["user_id"] is string ? <string>bmiData["user_id"] : "";
            decimal weight = bmiData["weight"] is decimal ? <decimal>bmiData["weight"] : 0.0;
            decimal height = bmiData["height"] is decimal ? <decimal>bmiData["height"] : 0.0;
            decimal bmi = bmiData["bmi"] is decimal ? <decimal>bmiData["bmi"] : 0.0;
            string classification = bmiData["classification"] is string ? <string>bmiData["classification"] : "";
            string? notes = bmiData["notes"] is string ? <string>bmiData["notes"] : ();
            string createdAt = bmiData["created_at"] is string ? <string>bmiData["created_at"] : "";
            
            io:println("DEBUG: Transformed BMI record - id: " + id + ", weight: " + weight.toString() + ", height: " + height.toString() + ", bmi: " + bmi.toString());
            
            record {
                string id;
                string userId;
                decimal weight;
                decimal height;
                decimal bmi;
                string classification;
                string? notes;
                string createdAt;
            } transformedBmiRecord = {
                id: id,
                userId: dbUserId,
                weight: weight,
                height: height,
                bmi: bmi,
                classification: classification,
                notes: notes,
                createdAt: createdAt
            };
            
            transformedBmiRecords.push(transformedBmiRecord);
        }
        
        io:println("DEBUG: Returning " + transformedBmiRecords.length().toString() + " transformed BMI records");
        return <http:Ok>{ body: transformedBmiRecords };
    }

    // Login endpoint
    resource function post login(@http:Payload record {
        string email;
        string password;
    } loginData) returns http:Ok|http:Unauthorized|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("Login attempt for email: ", loginData.email);
        
        string hashedPassword = hashPassword(loginData.password);
        io:println("Hashed password: ", hashedPassword);
        
        // Debug: Check all users in database
        sql:ParameterizedQuery allUsersQuery = `SELECT id, first_name, last_name, email FROM users`;
        stream<record {}, sql:Error?> allUsersStream = dbClient->query(allUsersQuery);
        record {}[] allUsers = [];
        while true {
            record {}|sql:Error? row = allUsersStream.next();
            if row is record {} { allUsers.push(row); } else { break; }
        }
        io:println("Total users in database: ", allUsers.length());
        foreach record {} user in allUsers {
            string email = user["email"] is string ? user["email"].toString() : "NULL";
            io:println("User ID: ", user["id"].toString(), ", Email: ", email);
        }
        
        // Check if user exists and verify password
        sql:ParameterizedQuery loginQuery = `SELECT id, first_name, last_name, email, password FROM users WHERE email = ${loginData.email}`;
        io:println("Login query: ", loginQuery);
        stream<record {}, sql:Error?> s = dbClient->query(loginQuery);
        record {}[] users = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { users.push(row); } else { break; }
        }
        
        io:println("Users found with this email: ", users.length());
        
        if users.length() == 0 {
            io:println("No user found with email: ", loginData.email);
            return <http:Unauthorized>{ body: { message: "Invalid email or password" } };
        }
        
        record {} user = users[0];
        
        // Debug: Show the entire result set
        io:println("=== DEBUG INFO ===");
        io:println("Raw user record: ", user);
        io:println("User record keys: ", user.keys());
        io:println("User record length: ", user.length());
        
        // The data is nested inside a 'value' field due to MySQL result parsing
        string storedPassword = "";
        string userEmail = "";
        string userId = "";
        
        if user.hasKey("value") {
            record {} userData = <record {}>user["value"];
            io:println("User data record: ", userData);
            io:println("User data keys: ", userData.keys());
            
            if userData.hasKey("password") {
                storedPassword = userData["password"].toString();
                io:println("Password field exists and value: ", storedPassword);
            } else {
                io:println("Password field does NOT exist in userData");
            }
            
            if userData.hasKey("email") {
                userEmail = userData["email"].toString();
                io:println("Email field exists and value: ", userEmail);
            } else {
                io:println("Email field does NOT exist in userData");
            }
            
            if userData.hasKey("id") {
                userId = userData["id"].toString();
                io:println("ID field exists and value: ", userId);
            } else {
                io:println("ID field does NOT exist in userData");
            }
        } else {
            io:println("No 'value' field found in user record");
        }
        
        io:println("User typed password (raw): ", loginData.password);
        io:println("User typed password length: ", loginData.password.length());
        io:println("Hashed password: ", hashedPassword);
        io:println("Hashed password length: ", hashedPassword.length());
        io:println("Password match: ", hashedPassword == storedPassword);
        io:println("==================");
        
        if (hashedPassword != storedPassword) {
            io:println("Password does not match");
            return <http:Unauthorized>{ body: { message: "Invalid email or password" } };
        }
        
        string name = user["first_name"].toString() + " " + user["last_name"].toString();
        
        io:println("Login successful for user: ", name);
        
        return <http:Ok>{ body: { message: "Login successful", userId: userId, name: name, email: userEmail } };
    }

    // Update user profile endpoint
    resource function put updateUserProfile(@http:Payload record {
        string userId;
        string? firstName;
        string? lastName;
        string? email;
        string? gender;
        string? dateOfBirth;
        string? phoneNumber;
        string? photoDataUrl;
    } profileUpdate) returns http:Ok|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        // Build dynamic update query
        string updateFields = "";
        
        // Check for firstName field
        if (profileUpdate.firstName is string) {
            string firstName = <string>profileUpdate.firstName;
            updateFields += "first_name = '" + firstName + "', ";
        }
        
        // Check for lastName field
        if (profileUpdate.lastName is string) {
            string lastName = <string>profileUpdate.lastName;
            updateFields += "last_name = '" + lastName + "', ";
        }
        
        // Check for email field
        if (profileUpdate.email is string) {
            string email = <string>profileUpdate.email;
            updateFields += "email = '" + email + "', ";
        }
        
        // Check for gender field
        if (profileUpdate.gender is string) {
            string gender = <string>profileUpdate.gender;
            updateFields += "gender = '" + gender + "', ";
        }
        
        // Check for dateOfBirth field
        if (profileUpdate.dateOfBirth is string) {
            string dateOfBirth = <string>profileUpdate.dateOfBirth;
            updateFields += "date_of_birth = '" + dateOfBirth + "', ";
        }
        
        // Check for phoneNumber field
        if (profileUpdate.phoneNumber is string) {
            string phoneNumber = <string>profileUpdate.phoneNumber;
            updateFields += "phone_number = '" + phoneNumber + "', ";
        }
        
        // Check for photoDataUrl field
        if (profileUpdate.photoDataUrl is string) {
            string photoDataUrl = <string>profileUpdate.photoDataUrl;
            updateFields += "photo_data_url = '" + photoDataUrl + "', ";
        }
        
        // Remove trailing comma and space
        if (updateFields.length() > 2) {
            updateFields = updateFields.substring(0, updateFields.length() - 2);
        }
        
        if (updateFields == "") {
            return <http:BadRequest>{ body: { message: "No fields to update" } };
        }
        

        sql:ParameterizedQuery updateQuery = `UPDATE users SET ${updateFields} WHERE id = ${profileUpdate.userId}`;
        sql:ExecutionResult|sql:Error updateResult = dbClient->execute(updateQuery);
        if (updateResult is sql:Error) {
            return <http:InternalServerError>{ body: { message: "Error updating profile" } };
        }
        
        return <http:Ok>{ body: { message: "Profile updated successfully" } };
    }

    // Delete user profile endpoint
    resource function delete deleteProfile(@http:Payload record {
        string userId;
    } profileDelete) returns http:Ok|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        // Delete user and all related data (cascade delete)
        sql:ParameterizedQuery deleteQuery = `DELETE FROM users WHERE id = ${profileDelete.userId}`;
        sql:ExecutionResult|sql:Error deleteResult = dbClient->execute(deleteQuery);
        if deleteResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error deleting profile" } };
        }
        
        return <http:Ok>{ body: { message: "Profile deleted successfully" } };
    }

    // Add custom vaccine endpoint
    resource function post addCustomVaccine(@http:Payload record {
        string userId;
        record {
            string name;
            string dose;
            boolean received;
            boolean isCustom;
            int offsetMonths;
        } vaccine;
    } customVaccine) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery insertVaccine = `INSERT INTO vaccine_records (user_id, name, dose, received, is_custom, offset_months, created_at) VALUES (${customVaccine.userId}, ${customVaccine.vaccine.name}, ${customVaccine.vaccine.dose}, ${customVaccine.vaccine.received}, ${customVaccine.vaccine.isCustom}, ${customVaccine.vaccine.offsetMonths}, NOW())`;
        sql:ExecutionResult|sql:Error insRes = dbClient->execute(insertVaccine);
        if insRes is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding custom vaccine" } };
        }
        
        return <http:Created>{ body: { message: "Custom vaccine added successfully" } };
    }

    // Add doctor appointment endpoint
    resource function post addDocAppointment(@http:Payload record {
        string userId;
        string date;
        string time;
        string place;
        string disease;
    } appointment) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery insertAppointment = `INSERT INTO doc_appointments (user_id, date, time, place, disease, completed, created_at) VALUES (${appointment.userId}, ${appointment.date}, ${appointment.time}, ${appointment.place}, ${appointment.disease}, false, NOW())`;
        sql:ExecutionResult|sql:Error insRes = dbClient->execute(insertAppointment);
        if insRes is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding doctor appointment" } };
        }
        
        return <http:Created>{ body: { message: "Doctor appointment added successfully" } };
    }

    // Get appointments endpoint
    resource function get getAppointments(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery aq = `SELECT id, user_id, title, date, time, notes, completed, created_at FROM appointments WHERE user_id = ${userId}`;
        stream<record {}, sql:Error?> s = dbClient->query(aq);
        record {}[] appointments = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { appointments.push(row); } else { break; }
        }
        
        return <http:Ok>{ body: appointments };
    }

    // Add appointment endpoint
    resource function post addAppointment(@http:Payload record {
        string userId;
        string title;
        string date;
        string time;
        string? notes;
    } appointment) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery insertAppointment = `INSERT INTO appointments (user_id, title, date, time, notes, completed, created_at) VALUES (${appointment.userId}, ${appointment.title}, ${appointment.date}, ${appointment.time}, ${appointment.notes ?: ""}, false, NOW())`;
        sql:ExecutionResult|sql:Error insRes = dbClient->execute(insertAppointment);
        if insRes is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding appointment" } };
        }
        
        return <http:Created>{ body: { message: "Appointment added successfully" } };
    }

    // Update password endpoint (for fixing existing users)
    resource function put updatePassword(@http:Payload record {
        string email;
        string newPassword;
    } passwordUpdate) returns http:Ok|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        string hashedPassword = hashPassword(passwordUpdate.newPassword);
        
        sql:ParameterizedQuery updateQuery = `UPDATE users SET password = ${hashedPassword} WHERE email = ${passwordUpdate.email}`;
        sql:ExecutionResult|sql:Error updateResult = dbClient->execute(updateQuery);
        if updateResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error updating password" } };
        }
        
        return <http:Ok>{ body: { message: "Password updated successfully" } };
    }

    // Add BMI record endpoint
    resource function post addBmiRecord(@http:Payload record {
        string userId;
        float weight;
        float height;
        string date;
    } bmiRecord) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        float bmi = bmiRecord.weight / (bmiRecord.height * bmiRecord.height);
        
        // Get user profile to calculate age and use growth classification
        sql:ParameterizedQuery profileQuery = `SELECT gender, date_of_birth FROM users WHERE id = ${bmiRecord.userId}`;
        stream<record {}, sql:Error?> profileStream = dbClient->query(profileQuery);
        record {}[] profiles = [];
        while true {
            record {}|sql:Error? row = profileStream.next();
            if row is record {} { profiles.push(row); } else { break; }
        }
        
        string classification = "";
        if (profiles.length() > 0) {
            record {} profile = profiles[0];
            if (profile.hasKey("value")) {
                record {} profileData = <record {}>profile["value"];
                string gender = profileData.hasKey("gender") ? profileData["gender"].toString() : "";
                string dateOfBirth = profileData.hasKey("date_of_birth") ? profileData["date_of_birth"].toString() : "";
                
                if (gender != "" && dateOfBirth != "") {
                    int ageInMonths = calculateAgeInMonths(dateOfBirth);
                    if (ageInMonths <= 24) {
                        // Use WHO growth standards for children under 2 years
                        classification = getGrowthClassification(gender, ageInMonths, bmiRecord.weight);
                    } else {
                        // Use standard BMI classification for older ages
                        if (bmi < 18.5f) {
                            classification = "underweight";
                        } else if (bmi < 25.0f) {
                            classification = "healthy";
                        } else if (bmi < 30.0f) {
                            classification = "overweight";
                        } else {
                            classification = "obese";
                        }
                    }
                } else {
                    // Fallback to standard BMI classification
                    if (bmi < 18.5f) {
                        classification = "underweight";
                    } else if (bmi < 25.0f) {
                        classification = "healthy";
                    } else if (bmi < 30.0f) {
                        classification = "overweight";
                    } else {
                        classification = "obese";
                    }
                }
            }
        } else {
            // Fallback to standard BMI classification
            if (bmi < 18.5f) {
                classification = "underweight";
            } else if (bmi < 25.0f) {
                classification = "healthy";
            } else if (bmi < 30.0f) {
                classification = "overweight";
            } else {
                classification = "obese";
            }
        }
        
        sql:ParameterizedQuery insertQuery = `INSERT INTO bmi_records (user_id, weight, height, bmi, classification, created_at) VALUES (${bmiRecord.userId}, ${bmiRecord.weight}, ${bmiRecord.height}, ${bmi}, ${classification}, NOW())`;
        sql:ExecutionResult|sql:Error insertResult = dbClient->execute(insertQuery);
        if insertResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding BMI record" } };
        }
        
        return <http:Created>{ body: { message: "BMI record added successfully", bmi: bmi } };
    }

    // Add special notes endpoint
    resource function post addSpecialNotes(@http:Payload record {
        string userId;
        string notes;
    } specialNotes) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery updateQuery = `UPDATE users SET special_notes = ${specialNotes.notes} WHERE id = ${specialNotes.userId}`;
        sql:ExecutionResult|sql:Error updateResult = dbClient->execute(updateQuery);
        if updateResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding special notes" } };
        }
        
        return <http:Created>{ body: { message: "Special notes added successfully" } };
    }

    // Get special notes endpoint
    resource function get getSpecialNotes(string userId) returns http:Ok|http:NotFound|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        io:println("DEBUG: getSpecialNotes called with userId: " + userId);
        
        // First check if the special_notes column exists
        sql:ParameterizedQuery checkColumnQuery = `SHOW COLUMNS FROM users LIKE 'special_notes'`;
        stream<record {}, sql:Error?> columnCheck = dbClient->query(checkColumnQuery);
        record {}[] columnResults = [];
        while true {
            record {}|sql:Error? row = columnCheck.next();
            if row is record {} { columnResults.push(row); } else { break; }
        }
        
        io:println("DEBUG: special_notes column check results: " + columnResults.toString());
        
        if (columnResults.length() == 0) {
            // Column doesn't exist, return empty notes
            io:println("DEBUG: special_notes column not found, returning empty notes");
            return <http:Ok>{ body: { notes: "" } };
        }
        
        sql:ParameterizedQuery query = `SELECT special_notes FROM users WHERE id = ${userId}`;
        stream<record {}, sql:Error?> s = dbClient->query(query);
        record {}[] results = [];
        while true {
            record {}|sql:Error? row = s.next();
            if row is record {} { results.push(row); } else { break; }
        }
        
        io:println("DEBUG: getSpecialNotes query results: " + results.toString());
        
        if results.length() == 0 {
            io:println("DEBUG: User not found for special notes");
            return <http:NotFound>{ body: { message: "User not found" } };
        }
        
        string notes = results[0]["special_notes"] is string ? <string>results[0]["special_notes"] : "";
        io:println("DEBUG: Returning special notes: " + notes);
        
        return <http:Ok>{ body: { notes: notes } };
    }

    // Add vaccine record endpoint
    resource function post addVaccineRecord(@http:Payload record {
        string userId;
        string name;
        string dose;
        boolean received;
        string? receivedDate;
        boolean isCustom;
        int? offsetMonths;
    } vaccineRecord) returns http:Created|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery insertQuery = `INSERT INTO vaccine_records (user_id, name, dose, received, received_date, is_custom, offset_months, created_at) VALUES (${vaccineRecord.userId}, ${vaccineRecord.name}, ${vaccineRecord.dose}, ${vaccineRecord.received}, ${vaccineRecord.receivedDate ?: ""}, ${vaccineRecord.isCustom}, ${vaccineRecord.offsetMonths ?: 0}, NOW())`;
        sql:ExecutionResult|sql:Error insertResult = dbClient->execute(insertQuery);
        if insertResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error adding vaccine record" } };
        }
        
        return <http:Created>{ body: { message: "Vaccine record added successfully" } };
    }

    // Update appointment endpoint
    resource function put updateAppointment(@http:Payload record {
        string userId;
        string appointmentId;
        string? title;
        string? doctor;
        string? specialty;
        string? date;
        string? time;
        string? notes;
        boolean? completed;
    } appointmentUpdate) returns http:Ok|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        // Build dynamic update query
        string updateFields = "";
        if (appointmentUpdate.title is string) {
            updateFields += "title = '" + <string>appointmentUpdate.title + "', ";
        }
        if (appointmentUpdate.doctor is string) {
            updateFields += "doctor = '" + <string>appointmentUpdate.doctor + "', ";
        }
        if (appointmentUpdate.specialty is string) {
            updateFields += "specialty = '" + <string>appointmentUpdate.specialty + "', ";
        }
        if (appointmentUpdate.date is string) {
            updateFields += "date = '" + <string>appointmentUpdate.date + "', ";
        }
        if (appointmentUpdate.time is string) {
            updateFields += "time = '" + <string>appointmentUpdate.time + "', ";
        }
        if (appointmentUpdate.notes is string) {
            updateFields += "notes = '" + <string>appointmentUpdate.notes + "', ";
        }
        if (appointmentUpdate.completed is boolean) {
            updateFields += "completed = " + (<boolean>appointmentUpdate.completed ? "1" : "0") + ", ";
        }
        
        // Remove trailing comma and space
        if (updateFields.length() > 2) {
            updateFields = updateFields.substring(0, updateFields.length() - 2);
        }
        
        if (updateFields == "") {
            return <http:BadRequest>{ body: { message: "No fields to update" } };
        }
        
        sql:ParameterizedQuery updateQuery = `UPDATE appointments SET ${updateFields} WHERE id = ${appointmentUpdate.appointmentId} AND user_id = ${appointmentUpdate.userId}`;
        sql:ExecutionResult|sql:Error updateResult = dbClient->execute(updateQuery);
        if updateResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error updating appointment" } };
        }
        
        return <http:Ok>{ body: { message: "Appointment updated successfully" } };
    }

    // Delete appointment endpoint
    resource function delete deleteAppointment(@http:Payload record {
        string userId;
        string appointmentId;
    } appointmentDelete) returns http:Ok|http:BadRequest|http:InternalServerError|error {
        if globalClient is () {
            return <http:InternalServerError>{ body: { message: "Database not initialized" } };
        }
        mysql:Client dbClient = <mysql:Client>globalClient;
        
        sql:ParameterizedQuery deleteQuery = `DELETE FROM appointments WHERE id = ${appointmentDelete.appointmentId} AND user_id = ${appointmentDelete.userId}`;
        sql:ExecutionResult|sql:Error deleteResult = dbClient->execute(deleteQuery);
        if deleteResult is sql:Error {
            return <http:InternalServerError>{ body: { message: "Error deleting appointment" } };
        }
        
        return <http:Ok>{ body: { message: "Appointment deleted successfully" } };
    }
}
